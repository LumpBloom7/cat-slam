
using System;
using TorchSharp;
using TorchSharp.Modules;
using static TorchSharp.torch.nn;

namespace MyProject.NeuralNetwork
{
    public class Model
    {
        public Sequential seq;
        public Model(int inputDimension, int outputDimension)
        {
            Linear lin1 = Linear(inputSize: inputDimension, outputSize: 12);
            Linear lin2 = Linear(inputSize: 12, outputSize: 8);
            Linear lin3 = Linear(inputSize: 8, outputSize: outputDimension);
            ReLU relu = ReLU();
            var softmax = Softmax(-1);
            seq = Sequential(lin1, lin2, lin3, relu, softmax);
        }
        public int countNeurons()  //Method generated by LLM
        {
            //get amount of
            int totalWeights = 0;
            foreach (var layer in seq.modules())
            {
                if (layer is Linear linearLayer)
                {
                    // Get the number of weights for this layer
                    int numWeights = (int)(linearLayer.out_features * linearLayer.in_features);
                    int numBiases = (int)linearLayer.out_features;  // Biases are equal to the number of output features

                    // Add both the weights and biases for the layer
                    totalWeights += numWeights + numBiases;
                }
            }

            return totalWeights;
        }
        public void setWeights(float[] externalWeights) //Method generated by LLM
        {
            int index = 0;

            // Iterate through all layers in the Sequential container
            foreach (var layer in seq.modules())
            {
                if (layer is Linear linearLayer)
                {
                    // Get the number of input features and output features dynamically
                    int inputSize = (int)linearLayer.in_features;
                    int outputSize = (int)linearLayer.out_features;

                    // Calculate the number of weights for this layer (output_size * input_size)
                    int numWeights = inputSize * outputSize;

                    // Create a tensor from the external weights and reshape it to the correct shape
                    var weightTensor = torch.tensor(externalWeights[index..(index + numWeights)]).reshape(new long[] { outputSize, inputSize });

                    // Use copy_() to assign the weights to the layer's weight tensor
                    linearLayer.weight.copy_(weightTensor); // Correct way to assign the tensor

                    // Move the index forward by the number of weights we just used
                    index += numWeights;
                }
            }
        }

    }

    public class Network
    {
        public void run()
        {
            float[] sensorsData = [2.0f, 4.0f, 3.4f, 3.1f, 2.0f, 4.0f, 3.4f, 3.1f, 2.0f, 4.0f, 3.4f, 3.1f];
            float[] motorData = [2.5f, 0f]; // max is 5
            int inDimen = sensorsData.Length;
            int outDimen = motorData.Length;

            var model = new Model(inDimen, outDimen);
            Console.WriteLine("neurons in network: " + model.countNeurons());
            var seq = model.seq;

            var x = torch.tensor(sensorsData);
            var y = torch.tensor(new float[] { 2f, 3f });

            var optimizer = torch.optim.Adam(seq.parameters());

            for (int i = 0; i < 10; i++)
            {
                using var eval = seq.forward(x);
                using var output = functional.mse_loss(eval, y, Reduction.Sum);
                Console.WriteLine(eval.ToString(TensorStringStyle.Numpy));
                optimizer.zero_grad();
                output.backward();
                optimizer.step();
            }


            Console.WriteLine("Model Built.");
        }
    }
}
